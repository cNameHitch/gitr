# Feature Specification: Large-Repo Performance Optimization

**Feature Branch**: `022-perf-optimization`
**Created**: 2026-02-08
**Status**: Draft
**Input**: User description: "Close the performance gap between gitr and C git on large repositories while maintaining 100% byte-compatible output."

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Fast History Browsing on Large Repos (Priority: P1)

A developer working on a large repository (10,000+ commits, 5,000+ files) runs `gitr log` to browse recent commit history. Today this takes roughly twice as long as C git. After optimization, history browsing completes at near-parity with C git, so developers do not notice a performance difference when switching between tools.

**Why this priority**: History traversal (`log`, `rev-list`) is the most commonly used operation that currently underperforms. It is the foundation for many other commands (blame, merge-base, reachability checks) and delivers the broadest performance improvement across the tool.

**Independent Test**: Can be tested by running `gitr log` and `gitr rev-list` on a large repository and comparing wall-clock time against C git. Delivers value as a standalone improvement to all history-based workflows.

**Acceptance Scenarios**:

1. **Given** a repository with 10,000+ commits, **When** the user runs `gitr log`, **Then** output completes within 1.2x the time of `git log` and the output is byte-identical.
2. **Given** a repository with 10,000+ commits, **When** the user runs `gitr rev-list --all`, **Then** output completes within 1.2x the time of `git rev-list --all` and lists identical commit hashes in identical order.
3. **Given** a repository with a commit-graph file generated by C git, **When** the user runs `gitr log`, **Then** gitr reads and leverages the existing commit-graph file transparently.

---

### User Story 2 - Responsive Working Tree Status on Large Repos (Priority: P2)

A developer with a large working tree (5,000+ tracked files) runs `gitr status` to check for modifications before committing. Today this is nearly 2x slower than C git on large repos. After optimization, status checks complete at near-parity, keeping the developer's workflow fast.

**Why this priority**: `status` is the single most frequently invoked command in typical Git workflows (called by IDE integrations, shell prompts, and developers manually). The 1.9x slowdown on large repos is highly visible.

**Independent Test**: Can be tested by running `gitr status` on a large repository with a mix of clean, modified, and untracked files. Compare wall-clock time against C git. Delivers value as a standalone improvement to everyday developer workflow.

**Acceptance Scenarios**:

1. **Given** a large repository with 5,000+ tracked files and no modifications, **When** the user runs `gitr status`, **Then** output completes within 1.2x the time of `git status` and output is byte-identical.
2. **Given** a large repository with scattered modifications across the tree, **When** the user runs `gitr status`, **Then** modified files are reported in the same time envelope with identical output.
3. **Given** a large repository, **When** the user runs `gitr status` repeatedly, **Then** subsequent runs are no slower than the first (no warm-up penalty).

---

### User Story 3 - Efficient Blame on Large Files with Deep History (Priority: P3)

A developer runs `gitr blame` on a file with extensive edit history to understand who changed each line. Today this is 2.3x slower than C git on large repos — the largest regression. After optimization, blame completes within a reasonable margin of C git.

**Why this priority**: Blame is the worst-performing operation (2.3x slower) but is used less frequently than log or status. It is also the most complex optimization target, combining history traversal, diff computation, and line-tracking. Improvements to history traversal (P1) provide a foundation that blame builds upon.

**Independent Test**: Can be tested by running `gitr blame` on a file with 500+ commits touching it in a large repository. Compare wall-clock time and output against C git. Delivers value as a standalone improvement to code archaeology workflows.

**Acceptance Scenarios**:

1. **Given** a large repository with a file that has 500+ commits in its history, **When** the user runs `gitr blame <file>`, **Then** output completes within 1.5x the time of `git blame <file>` and output is byte-identical.
2. **Given** a repository where C git has generated a commit-graph file, **When** the user runs `gitr blame`, **Then** gitr leverages the commit-graph to accelerate history traversal during blame.

---

### User Story 4 - Commit-Graph Generation for Sustained Performance (Priority: P4)

A repository maintainer runs `gitr commit-graph write` (or it is triggered automatically during maintenance operations) to generate a commit-graph file. This file is then used by subsequent gitr and C git operations to accelerate history traversal. The generated file is fully compatible with C git's commit-graph format.

**Why this priority**: Generating commit-graph files is the enabler for P1–P3 improvements. However, repositories may already have commit-graph files generated by C git, so read support (covered by P1) is more immediately impactful than write support.

**Independent Test**: Can be tested by running `gitr commit-graph write`, then verifying C git can read the generated file and vice versa. Delivers value as a standalone maintenance capability.

**Acceptance Scenarios**:

1. **Given** a repository without a commit-graph file, **When** the user runs `gitr commit-graph write`, **Then** a commit-graph file is created that C git can read and validate.
2. **Given** a commit-graph file generated by gitr, **When** C git runs `git log`, **Then** C git successfully uses the gitr-generated commit-graph file with no errors.
3. **Given** a repository with an existing commit-graph file, **When** the user runs `gitr commit-graph write`, **Then** the file is updated to include new commits while preserving compatibility.

---

### User Story 5 - No Regression on Small/Medium Repos (Priority: P1)

A developer working on a small or medium repository experiences the same fast performance they have today. All optimizations for large repos must not introduce overhead that slows down small repo operations where gitr already dominates C git by 3–5x.

**Why this priority**: Equal to P1 because protecting the existing performance advantage is as important as closing the large-repo gap. Regressions would undermine user trust.

**Independent Test**: Can be tested by running the existing benchmark suite on small and medium repositories before and after changes. No individual operation should regress by more than 5%.

**Acceptance Scenarios**:

1. **Given** a small repository (< 100 commits, < 50 files), **When** the user runs any gitr command, **Then** performance does not regress by more than 5% compared to pre-optimization baselines.
2. **Given** a medium repository (100–1,000 commits, 50–500 files), **When** the user runs any gitr command, **Then** performance does not regress by more than 5% compared to pre-optimization baselines.

---

### Edge Cases

- What happens when the commit-graph file is corrupt or truncated? Gitr must fall back to standard packfile traversal gracefully with no crash or incorrect output.
- What happens when the commit-graph file is out of date (missing recent commits)? Gitr must still produce correct results by falling back to packfile reads for commits not in the graph.
- What happens when a repository has no packfiles (all loose objects)? Optimizations targeting packfile access must not break or slow down loose-object-only repos.
- What happens when the index file is being concurrently modified (e.g., another gitr/git process)? Status must handle lock contention gracefully.
- What happens on repositories with extremely long delta chains in packfiles? Object resolution must not stack-overflow or allocate unbounded memory.
- What happens when the repository has split commit-graph chains (multiple .graph files)? Gitr must support the chain format used by C git.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST read commit-graph files in the format specified by Git's `commit-graph` documentation (version 1, with generation number v1 and v2 support).
- **FR-002**: System MUST write commit-graph files that are byte-compatible with C git's commit-graph format, readable by `git commit-graph verify`.
- **FR-003**: System MUST use commit-graph data (parent pointers, tree OIDs, generation numbers) to accelerate `log`, `rev-list`, and `blame` operations when a commit-graph file is present.
- **FR-004**: System MUST fall back to standard object resolution when a commit-graph file is absent, corrupt, or incomplete, with no change in output correctness.
- **FR-005**: System MUST produce byte-identical output to C git for all optimized operations (`status`, `log`, `log --oneline`, `rev-list`, `blame`, `ls-files`).
- **FR-006**: System MUST not regress performance on small or medium repositories (< 1,000 commits) by more than 5% on any operation.
- **FR-007**: System MUST support generation-number-based commit pruning during revision walks to skip unreachable commits early.
- **FR-008**: System MUST implement an object read cache to reduce redundant packfile lookups during operations that access the same objects repeatedly (e.g., blame, log with diffs).
- **FR-009**: System MUST optimize index file parsing to minimize allocation overhead for large indexes (5,000+ entries).
- **FR-010**: System MUST parallelize working-tree stat() calls during `status` on repositories with large file counts.
- **FR-011**: System MUST support split commit-graph chains (incremental commit-graph files) as used by C git for large repositories.
- **FR-012**: System MUST validate commit-graph checksums on load and reject corrupt files gracefully.

### Key Entities

- **Commit-Graph File**: A binary file (`.git/objects/info/commit-graph`) that caches commit metadata — OID, tree OID, parent OIDs, generation number, and commit timestamp — in a memory-mappable format for fast lookups without parsing packfiles.
- **Commit-Graph Chain**: A set of incremental commit-graph files (`.git/objects/info/commit-graphs/graph-*.graph`) that layer on top of each other, allowing new commits to be appended without rewriting the entire graph.
- **Object Cache**: An in-memory LRU cache that stores recently accessed Git objects (commits, trees, blobs) to avoid repeated decompression and delta resolution from packfiles.
- **Generation Number**: A topological ordering metric stored in the commit-graph that allows revision walks to prune unreachable commits without traversing them, significantly reducing work for bounded history queries.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: `gitr log` on a repository with 10,000+ commits completes within 1.2x the wall-clock time of `git log` (target: ~26ms, down from 42ms).
- **SC-002**: `gitr status` on a repository with 5,000+ tracked files completes within 1.2x the wall-clock time of `git status` (target: ~33ms, down from 52.3ms).
- **SC-003**: `gitr rev-list --all` on a repository with 10,000+ commits completes within 1.2x the wall-clock time of `git rev-list --all` (target: ~21ms, down from 28.5ms).
- **SC-004**: `gitr blame` on a file with 500+ commits in its history completes within 1.5x the wall-clock time of `git blame` (target: ~80ms, down from 122.5ms).
- **SC-005**: No operation on small repositories (< 100 commits) regresses by more than 5% compared to pre-optimization benchmarks.
- **SC-006**: No operation on medium repositories (100–1,000 commits) regresses by more than 5% compared to pre-optimization benchmarks.
- **SC-007**: Commit-graph files generated by gitr pass `git commit-graph verify` with zero errors.
- **SC-008**: All optimized commands produce byte-identical output to their C git equivalents across the full test suite.

## Assumptions

- Repositories used for benchmarking have characteristics similar to medium-to-large open-source projects (10,000+ commits, 5,000+ files, standard packfile layouts).
- C git's commit-graph format specification is stable and will not change incompatibly during the development of this feature.
- The existing benchmark infrastructure (documented in `docs/benchmark_summary.md`) will be used to validate performance improvements.
- Parallel working-tree scanning uses the thread pool already available via the `rayon` dependency — no new threading model is introduced.
- The object cache uses a bounded LRU strategy with a reasonable default size (e.g., 1,024 entries) that works well for typical operations without user configuration.